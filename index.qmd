---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: false
  eval: true
---
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```



### 1) Expected Value After 1 Flip

After one flip, the expected value of your account balance is **greater than** $30,000. The calculation shows that with a fair coin flip (50% probability for each outcome), you have a 50% chance of ending up with $45,000 (heads: +50%) and a 50% chance of ending up with $18,000 (tails: -40%). The expected value is $31,500, which represents a **gain of $1,500 or 5%** above your initial buy-in.

Based on expected value alone, this simple analysis suggests you should buy-in to the game, as it offers a positive expected return. However, this single-metric analysis overlooks the substantial risk: you have a 50% chance of losing $12,000 (40% of your investment) in just one flip. This highlights the importance of considering both expected value and risk when making investment decisions, especially when multiple periods are involved.

```{python}
#| label: q1-expected-value-py
#| echo: false

# Initial buy-in
initial_balance = 30000

# After one flip:
# - Heads (50%): balance increases by 50% → multiply by 1.5
# - Tails (50%): balance decreases by 40% → multiply by 0.6

balance_heads = initial_balance * 1.5
balance_tails = initial_balance * 0.6

print(f"Initial balance: ${initial_balance:,.2f}")
print(f"\nAfter one flip:")
print(f"  Heads (50% probability): ${balance_heads:,.2f}")
print(f"  Tails (50% probability): ${balance_tails:,.2f}")

# Expected value calculation
prob_heads = 0.5
prob_tails = 0.5
expected_value = prob_heads * balance_heads + prob_tails * balance_tails

print(f"\nExpected Value (EV) after one flip:")
print(f"  EV = 0.5 × ${balance_heads:,.2f} + 0.5 × ${balance_tails:,.2f}")
print(f"  EV = ${expected_value:,.2f}")

# Compare to initial balance
difference = expected_value - initial_balance
percent_gain = (difference / initial_balance) * 100

print(f"\nComparison to initial balance:")
print(f"  EV - Initial = ${difference:,.2f}")
print(f"  Gain as % of buy-in: {percent_gain:.2f}%")

# Conclusion
print(f"\nConclusion:")
if expected_value > initial_balance:
    print(f"  Expected value (${expected_value:,.2f}) > Initial balance (${initial_balance:,.2f})")
    print(f"  The expected value suggests a positive return of {percent_gain:.2f}%")
elif expected_value < initial_balance:
    print(f"  Expected value (${expected_value:,.2f}) < Initial balance (${initial_balance:,.2f})")
else:
    print(f"  Expected value (${expected_value:,.2f}) = Initial balance (${initial_balance:,.2f})")
```

### 2) Single Simulation Over Time (Narrative + Plot)

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance over time"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_balance = 30000
# Starting at age 24, playing until age 75 = 51 years
n_periods = 51

# Simulate one path
balance = initial_balance
balances = [balance]
coin_flips = []

for year in range(n_periods):
    # Flip coin: 1 = heads (50% gain), 0 = tails (40% loss)
    flip = np.random.binomial(1, 0.5)
    coin_flips.append(flip)
    
    if flip == 1:  # Heads
        balance = balance * 1.5
    else:  # Tails
        balance = balance * 0.6
    
    balances.append(balance)

# Create time series plot using matplotlib OO style
fig, ax = plt.subplots(figsize=(8, 6))
years = np.arange(0, n_periods + 1)
ax.plot(years, balances, linewidth=2, color='steelblue')
ax.axhline(y=initial_balance, color='red', linestyle='--', linewidth=1.5, label=f'Initial investment (${initial_balance:,.0f})')
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.set_title('Single Simulation: Account Balance Over Time', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.3)
ax.legend()
ax.set_xlim(0, n_periods)

# Format y-axis to show currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Print summary statistics
final_balance = balances[-1]
net_gain_loss = final_balance - initial_balance
percent_change = (net_gain_loss / initial_balance) * 100
num_heads = sum(coin_flips)
num_tails = n_periods - num_heads

print(f"\nSimulation Summary:")
print(f"  Initial balance: ${initial_balance:,.2f}")
print(f"  Final balance: ${final_balance:,.2f}")
print(f"  Net gain/loss: ${net_gain_loss:,.2f} ({percent_change:+.1f}%)")
print(f"  Coin flips: {num_heads} heads, {num_tails} tails")
```

In this single simulation path, the account balance starts at $30,000 and fluctuates significantly over the 51-year period (from age 24 to age 75) where the balance evolves through a series of coin flips, where each heads increases the balance by 50% and each tails decreases it by 40%. 

Looking at this particular run, the outcome is **catastrophic**: despite starting with a $30,000 investment and a positive expected value per flip, this simulation ends with approximately $584—a loss of over **98%** of the initial investment. The volatility is immediately apparent—each flip has substantial impact on the account value. Even with a positive expected value per flip, the compounded nature of these fluctuations means that a few consecutive tails can dramatically reduce the balance. Once the balance drops significantly, even heads become less effective at recovery because they're multiplying a smaller base value.

**Am I happy with this outcome? I am not.** This single simulation reveals the risk: despite the positive expected value calculated in Question 1, there's a significant chance of ending with less than the original $30,000 investment—in this case, nearly losing everything. The dramatic downward trajectory shown in the plot highlights why expected value alone is insufficient for making this decision. This outcome demonstrates that what matters in the long run isn't just the expected value, but also the distribution of outcomes and the risk of severe losses.

### 3) 100 Simulations: Distribution of Final Balances

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_balance = 30000
n_periods = 51  # Age 24 to 75 = 51 years
n_simulations = 100

# Function to run one simulation
def run_simulation(initial_balance, n_periods):
    balance = initial_balance
    for year in range(n_periods):
        flip = np.random.binomial(1, 0.5)  # 1 = heads, 0 = tails
        if flip == 1:  # Heads: +50%
            balance = balance * 1.5
        else:  # Tails: -40%
            balance = balance * 0.6
    return balance

# Run 100 simulations
final_balances = []
for sim in range(n_simulations):
    final_balance = run_simulation(initial_balance, n_periods)
    final_balances.append(final_balance)

final_balances = np.array(final_balances)

# Calculate statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
prob_above_initial = np.mean(final_balances > initial_balance)

# Create a beautiful histogram with log-scale bins
fig, ax = plt.subplots(figsize=(8, 6))

# Create log-spaced bins for proper log scale histogram
min_val = final_balances[final_balances > 0].min()
max_val = final_balances.max()
log_bins = np.logspace(np.log10(min_val), np.log10(max_val), 50)

# Create histogram with log-spaced bins
n, bins, patches = ax.hist(final_balances, bins=log_bins, color='#5B8DEF', 
                           edgecolor='#2E5C9A', linewidth=1.2, alpha=0.8)

# Color gradient for bars (darker = more frequent)
colors = plt.cm.Blues(np.linspace(0.4, 0.9, len(patches)))
for patch, color in zip(patches, colors):
    patch.set_facecolor(color)

# Set log scale
ax.set_xscale('log')

# Add reference lines with clean styling
ax.axvline(x=initial_balance, color='#E63946', linestyle='--', 
           linewidth=3, label=f'Initial: ${initial_balance:,.0f}', 
           zorder=10, alpha=0.9)
ax.axvline(x=mean_balance, color='#06A77D', linestyle='--', 
           linewidth=3, label=f'Mean: ${mean_balance:,.0f}', 
           zorder=10, alpha=0.9)
ax.axvline(x=median_balance, color='#F77F00', linestyle='--', 
           linewidth=3, label=f'Median: ${median_balance:,.0f}', 
           zorder=10, alpha=0.9)

# Clean, modern formatting
ax.set_xlabel('Final Account Balance ($)', fontsize=14, fontweight='600', color='#2C3E50')
ax.set_ylabel('Frequency', fontsize=14, fontweight='600', color='#2C3E50')
ax.set_title('Distribution of Final Balances Across 100 Simulations', 
            fontsize=16, fontweight='bold', pad=20, color='#2C3E50')

# Format x-axis with minimal labels (only powers of 10)
from matplotlib.ticker import FuncFormatter
# Determine the range and show only powers of 10
min_log = int(np.floor(np.log10(final_balances[final_balances > 0].min())))
max_log = int(np.ceil(np.log10(final_balances.max())))
# Show only powers of 10 (fewest labels possible while still readable)
tick_values = [10**i for i in range(min_log, max_log + 1)]
ax.set_xticks(tick_values)

# Format with clean labels
def format_currency(x, pos):
    if x < 1000:
        return f'${x:.0f}'
    elif x < 1e6:
        return f'${x/1000:.0f}K'
    elif x < 1e9:
        return f'${x/1e6:.1f}M'
    else:
        return f'${x/1e9:.1f}B'
ax.xaxis.set_major_formatter(FuncFormatter(format_currency))
# Remove minor ticks
ax.xaxis.set_minor_locator(plt.NullLocator())

# Beautiful, minimal styling
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_color('#BDC3C7')
ax.spines['left'].set_linewidth(1.5)
ax.spines['bottom'].set_color('#BDC3C7')
ax.spines['bottom'].set_linewidth(1.5)
ax.grid(True, alpha=0.25, linestyle='-', linewidth=0.8, color='#95A5A6', axis='both')
ax.set_facecolor('#F8F9FA')
ax.tick_params(colors='#34495E', labelsize=11)

# Elegant legend
legend = ax.legend(loc='upper left', fontsize=12, frameon=True, 
                   fancybox=False, shadow=False, framealpha=1.0,
                   edgecolor='#BDC3C7', facecolor='white', 
                   labelspacing=0.8, handlelength=2.5)
legend.get_frame().set_linewidth(1.5)

plt.tight_layout()
plt.show()

# Print statistics
print(f"\nDistribution Statistics (100 simulations):")
print(f"  Mean final balance: ${mean_balance:,.2f}")
print(f"  Median final balance: ${median_balance:,.2f}")
print(f"  Minimum final balance: ${np.min(final_balances):,.2f}")
print(f"  Maximum final balance: ${np.max(final_balances):,.2f}")
print(f"\nProbability that final balance > ${initial_balance:,.0f}: {prob_above_initial:.3f} ({prob_above_initial*100:.1f}%)")
print(f"\nOutcomes breakdown:")
print(f"  Above initial investment: {np.sum(final_balances > initial_balance)} simulations ({np.sum(final_balances > initial_balance)/n_simulations*100:.1f}%)")
print(f"  Below initial investment: {np.sum(final_balances <= initial_balance)} simulations ({np.sum(final_balances <= initial_balance)/n_simulations*100:.1f}%)")
```

Running 100 simulations reveals a highly skewed distribution of final account balances. The histogram above shows that while the mean final balance is substantial at approximately $268,905 (due to a few extremely large outcomes), the median is only $3,231—nearly 83 times smaller than the mean. This dramatic difference highlights the extreme skewness: most simulations end with final balances well below the initial $30,000 investment, while a few lucky paths create massive values.

The distribution is **highly right-skewed**, with most outcomes clustered near zero or very low values (the minimum was just $0.34—essentially nothing), while one exceptional simulation resulted in over $12.3 million. This asymmetry occurs because losses compound more effectively than gains in this game: once the balance drops significantly, it becomes difficult to recover, but when luck is favorable, the exponential growth from consecutive heads can create massive values that inflate the mean.

**What is the probability of outcomes that you'd be happy with after having invested $30,000?**

The probability of ending with more than the initial $30,000 investment is **0.210 (21.0%)**, which means that only 21 out of 100 simulations result in a positive return. This is a stark contrast to the positive expected value per flip calculated in Question 1. However, "happiness" depends on one's definition:

- **Minimum happiness threshold**: If you'd be happy simply with any return above $30,000, then only **21%** of outcomes meet this criterion—meaning you have a **79% chance of losing money or breaking even**.
- **Realistic happiness threshold**: If you'd want at least a modest return (say, $50,000 or double the investment), the probability drops even further, as most of the 21 successful outcomes cluster just above the initial investment while a few are extreme outliers that drag up the mean.
- **The harsh reality**: Despite the positive expected value per flip, **79% of simulations result in losses**, with many ending with nearly nothing. The mean ($268,905) being dramatically higher than the median ($3,231) indicates that average performance is heavily inflated by rare but extreme positive outcomes—if you're not one of the lucky few, your typical outcome is a devastating loss.

This distribution demonstrates why expected value alone is misleading: while the game has positive expected value, most realizations (79%) result in losses, making it a poor investment strategy despite its theoretical appeal. The 51-year time horizon amplifies this risk, as the compounding of volatility creates this highly skewed distribution where most paths lead to ruin.

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: false

# TODO: Using the 100 simulations above, estimate P(final > 30000)
# - Print numeric result with 3 decimals

```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies

```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1–5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist ✅

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch → main → /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

